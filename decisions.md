# JamVote 의사결정 내역

> 프로젝트 개발 과정에서 내린 주요 기술적, 기능적 결정과 그 근거를 기록합니다.

---

## 1. 데이터베이스: MongoDB 선택

**결정일**: 2025-10-14

### 결정 내용
관계형 DB(MySQL, PostgreSQL) 대신 MongoDB 사용

### 근거
#### 장점
- **빠른 개발**: 스키마 유연성, 초기 필드 추가/변경 용이
- **학습 곡선**: 관계형 DB 경험자도 쉽게 적응 (Mongoose ODM 사용)
- **바이브 코딩 친화적**: 표준화된 패턴, 풍부한 예제
- **무료 호스팅**: MongoDB Atlas 무료 티어 512MB (충분)
- **JSON 친화적**: 프론트엔드와 데이터 구조 일치

#### 고려사항
- 관계형 DB 대비 트랜잭션 지원 약함 → 이 프로젝트에서는 불필요
- JOIN 성능 → Mongoose `populate()`로 해결 가능

### 구현 예시
```javascript
// 간단한 Insert
await db.collection('jams').insertOne({
  jamId: 'abc123',
  name: '우리 밴드',
  expireAt: new Date('2025-05-01')
});

// Populate (JOIN)
await Song.find({ jamId }).populate('votes');
```

---

## 2. 보안 수준: 편의성 우선

**결정일**: 2025-10-14

### 결정 내용
최소한의 보안 조치만 적용, 편의성 우선

### 기본 보안 조치
- ✅ bcrypt 비밀번호 해시 (saltRounds: 10)
- ✅ 방 ID 랜덤 생성 (6자리 영문+숫자, 21억 가지 조합)
- ✅ HTTPS (Vercel/Railway 자동 제공)

### 생략한 보안 기능
- ❌ 2단계 인증
- ❌ 이메일 인증
- ❌ CSRF 토큰 (Phase 1)
- ❌ Rate limiting (Phase 2로 연기)

### 근거
1. **서비스 특성**
   - 일회성 사용 (30~90일 후 자동 삭제)
   - 중요 개인정보 없음 (이메일, 전화번호 불필요)
   - 밴드 멤버 간 사회적 통제 (악의적 행동 시 즉시 인지)

2. **피해 범위 제한**
   - 최악의 경우: 한 방의 투표 데이터만 영향
   - 실제 피해: 합주곡 선정 방해 정도

3. **벤치마크**
   - When2Meet, Doodle 등 유사 서비스도 비슷한 보안 수준

### 보안 vs 편의성 트레이드오프
| 기능 | 보안 위험 | 편의성 이득 | 결정 |
|------|----------|------------|------|
| 비밀번호 선택 사항 | 타인 접근 가능 | 진입장벽 낮춤 | ✅ 채택 |
| 비밀번호 없는 수정 | 악의적 수정 | UX 간소화 | ✅ 채택 |
| localStorage 세션 | XSS 위험 | 재로그인 불필요 | ✅ 채택 |

---

## 3. 이름 중복 체크: 대소문자 무시 + 공백 제거

**결정일**: 2025-10-14

### 결정 내용
이름 중복 체크 시 `normalizedName` 사용 (소문자 변환 + 공백 제거)

### 정규화 규칙
```javascript
function normalizeUsername(name) {
  return name.trim().toLowerCase();
}
```

### 동작 예시
| 입력 1 | 입력 2 | 중복 여부 |
|--------|--------|----------|
| 김철수 | 김철수 | ❌ 중복 |
| John | john | ❌ 중복 |
| " 김철수 " | "김철수" | ❌ 중복 |
| 김철수 | 철수 | ✅ 허용 |

### 근거
1. **한글 이름**: 대소문자 개념 없음 (주 사용층)
2. **영문 이름**: "John"과 "john"을 다른 사람으로 구분하면 혼란
3. **공백 실수**: 입력 실수로 인한 중복 가입 방지
4. **국제화 대비**: 외국인 밴드 멤버 배려

### 구현
```javascript
// DB 스키마
{
  name: "John", // 원본 유지 (화면 표시용)
  normalizedName: "john" // 중복 체크용
}

// 중복 체크
const exists = await User.findOne({
  jamId: jamId,
  normalizedName: normalizeUsername(inputName)
});
```

---

## 4. 투표 로직: 상호배타적 단일 투표

**결정일**: 2025-10-14

### 결정 내용
한 곡에 "좋아요"와 "불가능" 중 하나만 선택 가능

### 규칙
- ✅ 여러 곡에 투표 가능
- ✅ 투표 변경 가능 (좋아요 → 불가능)
- ✅ 투표 취소 가능
- ❌ 한 곡에 좋아요+불가능 동시 불가

### DB 제약
```javascript
// Unique Index: (songId, userName)
await Vote.collection.createIndex(
  { songId: 1, userName: 1 },
  { unique: true }
);
```

### 근거
- 논리적 모순 방지 (좋아요하면서 불가능?)
- 투표 결과 명확성 (찬성/반대 명확)
- 변경 허용으로 유연성 확보

---

## 5. 실시간 동기화: Socket.io 사용

**결정일**: 2025-10-14

### 결정 내용
Socket.io 사용, 폴링(Polling) 방식 미채택

### Socket.io 선택 근거
| 항목 | Socket.io | 폴링 (3초 주기) |
|------|-----------|----------------|
| 구현 난이도 | ⭐⭐☆☆☆ 쉬움 | ⭐☆☆☆☆ 더 쉬움 |
| 실시간성 | 즉시 반영 | 최대 3초 지연 |
| 서버 부하 | 낮음 | 높음 (불필요한 요청) |
| 바이브 코딩 | 공식 문서 풍부 | 직접 구현 |
| 재연결 처리 | 자동 | 수동 구현 필요 |

### 구현 예시
```javascript
// 서버
io.to(jamId).emit('newVote', { songId, userName, type });

// 클라이언트
socket.on('newVote', (data) => {
  setVotes(prev => [...prev, data]);
});
```

### 난이도 평가
- 2년차 백엔드 개발자 기준 **30분 내 구현 가능**
- 공식 문서 예제로 충분히 학습 가능

### 네트워크 불안정 대응
- Socket.io 자동 재연결 활용
- localStorage 임시 저장으로 데이터 손실 방지

---

## 6. 크론 잡 실행 시간: 매일 새벽 1시

**결정일**: 2025-10-14

### 결정 내용
만료된 방 삭제 작업을 매일 새벽 1시에 실행

```javascript
cron.schedule('0 1 * * *', async () => {
  await Jam.deleteMany({ expireAt: { $lt: new Date() } });
});
```

### 근거
- **사용자 영향 최소화**: 새벽 시간대 트래픽 최저
- **서버 부하 분산**: 낮 시간 API 요청과 겹치지 않음
- **UTC 고려 불필요**: 한국 사용자 대상 서비스

### 대안 검토
- 실시간 삭제 (expireAt 지나면 즉시): 불필요한 체크 증가
- 주 1회 실행: 만료된 방이 너무 오래 남음

---

## 7. 방 유효기한: 7/15/30/60/90일 선택

**결정일**: 2025-10-14

### 결정 내용
기본값 30일, 드롭다운에서 5가지 옵션 제공

### 근거
1. **사용자 편의성**: 직접 입력보다 선택이 쉬움
2. **일반적 사용 패턴**:
   - 7일: 급하게 곡 정하는 경우
   - 15일: 평균적인 합주 준비 기간
   - 30일: 기본값 (충분한 기간)
   - 60일: 여유 있게 논의
   - 90일: 장기 프로젝트 (최대 3개월)

### 대안 검토
- **자유 입력 (1~90일)**: 사용자 실수 가능성 (999일 입력 등)
- **무제한 옵션**: DB 용량 문제

---

## 8. UI/UX: 모바일 최적화 가이드

**결정일**: 2025-10-14

### 결정 내용
모바일 우선 디자인, 터치 친화적 UI

### 주요 가이드라인
| 항목 | 기준 | 근거 |
|------|------|------|
| 최소 화면 크기 | 320px | iPhone SE 등 소형 기기 대응 |
| 터치 영역 | 44x44px | Apple HIG 권장 |
| 폰트 크기 | 16px 이상 | 한글 가독성 (모바일) |
| 모달 스타일 | Bottom Sheet | 손가락 닿기 쉬움 |
| 자동 포커스 | 최소화 | 키보드 자동 팝업 방지 |

### 근거
- **사용자 환경**: "사용자들은 모바일 환경에서 접근할 가능성이 높다" (요구사항)
- **사용 맥락**: 밴드 연습실, 카페 등에서 스마트폰으로 사용
- **벤치마크**: 카카오톡 투표, 디스코드 모바일 참고

---

## 9. 기술 스택 선택 요약

**결정일**: 2025-10-14

### 프론트엔드: React + Vite
- **React**: 가장 많은 자료, 바이브 코딩 친화적
- **Vite**: CRA보다 빠른 빌드, 가벼움
- **TypeScript**: 타입 안정성 (개발 속도 향상)
- **Tailwind CSS**: 빠른 스타일링, 반응형 쉬움

### 백엔드: Node.js + Express
- **Node.js**: 프론트엔드와 동일 언어 (학습 부담 감소)
- **Express**: 미니멀, 빠른 API 구축

### 호스팅: 무료 티어 활용
- **Vercel (프론트)**: 자동 배포, 무료 HTTPS
- **Railway/Render (백엔드)**: 무료 티어, Docker 불필요
- **MongoDB Atlas (DB)**: 512MB 무료 (충분)

### 근거
- **개발 속도**: 빠른 프로토타이핑, MVP 빠른 출시
- **비용**: 초기 무료로 운영 가능
- **확장성**: 트래픽 증가 시 유료 전환 쉬움

---

## 10. Phase 구분 전략

**결정일**: 2025-10-14

### Phase 1 (MVP - 2주 목표)
핵심 기능만 구현, 최소 사용 가능한 상태
- 방 생성/접속
- 프로필 생성/로그인
- 곡 검색/추가
- 곡 투표
- 실시간 동기화

### Phase 2 (추가 기능 - 1주)
사용자 경험 개선
- 댓글
- 프로필 수정
- 방 유효기한 수정
- 피드백 모달
- Rate limiting

### Phase 3 (확장 - 추후)
부가 기능, 실제 사용 피드백 반영 후
- AI 자동 판단
- 데이터 백업
- 대댓글

### 근거
- **빠른 검증**: MVP로 사용자 반응 확인
- **리소스 집중**: 핵심 기능에 집중
- **유연한 조정**: Phase 2/3는 피드백 반영하여 조정 가능

---

## 변경 이력
- 2025-10-14: 초기 문서 작성
